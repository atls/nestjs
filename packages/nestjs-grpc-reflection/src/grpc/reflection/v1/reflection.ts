// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.6.1
//   protoc               unknown
// source: grpc/reflection/v1alpha/reflection.proto

/* eslint-disable */
import { BinaryReader }                 from '@bufbuild/protobuf/wire'
import { BinaryWriter }                 from '@bufbuild/protobuf/wire'
import { Metadata }                     from '@grpc/grpc-js'
import { UntypedServiceImplementation } from '@grpc/grpc-js'
import { GrpcMethod }                   from '@nestjs/microservices'
import { GrpcStreamMethod }             from '@nestjs/microservices'
import { handleBidiStreamingCall }      from '@grpc/grpc-js'
import { Observable }                   from 'rxjs'

export const protobufPackage = 'grpc.reflection.v1'

/** The message sent by the client when calling ServerReflectionInfo method. */
export interface ServerReflectionRequest {
  host: string
  /** Find a proto file by the file name. */
  fileByFilename?: string | undefined
  /**
   * Find the proto file that declares the given fully-qualified symbol name.
   * This field should be a fully-qualified symbol name
   * (e.g. <package>.<service>[.<method>] or <package>.<type>).
   */
  fileContainingSymbol?: string | undefined
  /**
   * Find the proto file which defines an extension extending the given
   * message type with the given field number.
   */
  fileContainingExtension?: ExtensionRequest | undefined
  /**
   * Finds the tag numbers used by all known extensions of the given message
   * type, and appends them to ExtensionNumberResponse in an undefined order.
   * Its corresponding method is best-effort: it's not guaranteed that the
   * reflection service will implement this method, and it's not guaranteed
   * that this method will provide all extensions. Returns
   * StatusCode::UNIMPLEMENTED if it's not implemented.
   * This field should be a fully-qualified type name. The format is
   * <package>.<type>
   */
  allExtensionNumbersOfType?: string | undefined
  /**
   * List the full names of registered services. The content will not be
   * checked.
   */
  listServices?: string | undefined
}

/**
 * The type name and extension number sent by the client when requesting
 * file_containing_extension.
 */
export interface ExtensionRequest {
  /** Fully-qualified type name. The format should be <package>.<type> */
  containingType: string
  extensionNumber: number
}

/** The message sent by the server to answer ServerReflectionInfo method. */
export interface ServerReflectionResponse {
  validHost: string
  originalRequest?: ServerReflectionRequest | undefined
  /**
   * This message is used to answer file_by_filename, file_containing_symbol,
   * file_containing_extension requests with transitive dependencies.
   * As the repeated label is not allowed in oneof fields, we use a
   * FileDescriptorResponse message to encapsulate the repeated fields.
   * The reflection service is allowed to avoid sending FileDescriptorProtos
   * that were previously sent in response to earlier requests in the stream.
   */
  fileDescriptorResponse?: FileDescriptorResponse | undefined
  /** This message is used to answer all_extension_numbers_of_type requests. */
  allExtensionNumbersResponse?: ExtensionNumberResponse | undefined
  /** This message is used to answer list_services requests. */
  listServicesResponse?: ListServiceResponse | undefined
  /** This message is used when an error occurs. */
  errorResponse?: ErrorResponse | undefined
}

/**
 * Serialized FileDescriptorProto messages sent by the server answering
 * a file_by_filename, file_containing_symbol, or file_containing_extension
 * request.
 */
export interface FileDescriptorResponse {
  /**
   * Serialized FileDescriptorProto messages. We avoid taking a dependency on
   * descriptor.proto, which uses proto2 only features, by making them opaque
   * bytes instead.
   */
  fileDescriptorProto: Uint8Array[]
}

/**
 * A list of extension numbers sent by the server answering
 * all_extension_numbers_of_type request.
 */
export interface ExtensionNumberResponse {
  /**
   * Full name of the base type, including the package name. The format
   * is <package>.<type>
   */
  baseTypeName: string
  extensionNumber: number[]
}

/** A list of ServiceResponse sent by the server answering list_services request. */
export interface ListServiceResponse {
  /**
   * The information of each service may be expanded in the future, so we use
   * ServiceResponse message to encapsulate it.
   */
  service: ServiceResponse[]
}

/**
 * The information of a single service used by ListServiceResponse to answer
 * list_services request.
 */
export interface ServiceResponse {
  /**
   * Full name of a registered service, including its package name. The format
   * is <package>.<service>
   */
  name: string
}

/** The error code and error message sent by the server when an error occurs. */
export interface ErrorResponse {
  /** This field uses the error codes defined in grpc::StatusCode. */
  errorCode: number
  errorMessage: string
}

export const GRPC_REFLECTION_V1_PACKAGE_NAME = 'grpc.reflection.v1'

function createBaseServerReflectionRequest(): ServerReflectionRequest {
  return { host: '' }
}

export const ServerReflectionRequest: MessageFns<ServerReflectionRequest> = {
  encode(
    message: ServerReflectionRequest,
    writer: BinaryWriter = new BinaryWriter()
  ): BinaryWriter {
    if (message.host !== '') {
      writer.uint32(10).string(message.host)
    }
    if (message.fileByFilename !== undefined) {
      writer.uint32(26).string(message.fileByFilename)
    }
    if (message.fileContainingSymbol !== undefined) {
      writer.uint32(34).string(message.fileContainingSymbol)
    }
    if (message.fileContainingExtension !== undefined) {
      ExtensionRequest.encode(message.fileContainingExtension, writer.uint32(42).fork()).join()
    }
    if (message.allExtensionNumbersOfType !== undefined) {
      writer.uint32(50).string(message.allExtensionNumbersOfType)
    }
    if (message.listServices !== undefined) {
      writer.uint32(58).string(message.listServices)
    }
    return writer
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ServerReflectionRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input)
    let end = length === undefined ? reader.len : reader.pos + length
    const message = createBaseServerReflectionRequest()
    while (reader.pos < end) {
      const tag = reader.uint32()
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break
          }

          message.host = reader.string()
          continue
        }
        case 3: {
          if (tag !== 26) {
            break
          }

          message.fileByFilename = reader.string()
          continue
        }
        case 4: {
          if (tag !== 34) {
            break
          }

          message.fileContainingSymbol = reader.string()
          continue
        }
        case 5: {
          if (tag !== 42) {
            break
          }

          message.fileContainingExtension = ExtensionRequest.decode(reader, reader.uint32())
          continue
        }
        case 6: {
          if (tag !== 50) {
            break
          }

          message.allExtensionNumbersOfType = reader.string()
          continue
        }
        case 7: {
          if (tag !== 58) {
            break
          }

          message.listServices = reader.string()
          continue
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break
      }
      reader.skip(tag & 7)
    }
    return message
  },
}

function createBaseExtensionRequest(): ExtensionRequest {
  return { containingType: '', extensionNumber: 0 }
}

export const ExtensionRequest: MessageFns<ExtensionRequest> = {
  encode(message: ExtensionRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.containingType !== '') {
      writer.uint32(10).string(message.containingType)
    }
    if (message.extensionNumber !== 0) {
      writer.uint32(16).int32(message.extensionNumber)
    }
    return writer
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ExtensionRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input)
    let end = length === undefined ? reader.len : reader.pos + length
    const message = createBaseExtensionRequest()
    while (reader.pos < end) {
      const tag = reader.uint32()
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break
          }

          message.containingType = reader.string()
          continue
        }
        case 2: {
          if (tag !== 16) {
            break
          }

          message.extensionNumber = reader.int32()
          continue
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break
      }
      reader.skip(tag & 7)
    }
    return message
  },
}

function createBaseServerReflectionResponse(): ServerReflectionResponse {
  return { validHost: '' }
}

export const ServerReflectionResponse: MessageFns<ServerReflectionResponse> = {
  encode(
    message: ServerReflectionResponse,
    writer: BinaryWriter = new BinaryWriter()
  ): BinaryWriter {
    if (message.validHost !== '') {
      writer.uint32(10).string(message.validHost)
    }
    if (message.originalRequest !== undefined) {
      ServerReflectionRequest.encode(message.originalRequest, writer.uint32(18).fork()).join()
    }
    if (message.fileDescriptorResponse !== undefined) {
      FileDescriptorResponse.encode(message.fileDescriptorResponse, writer.uint32(34).fork()).join()
    }
    if (message.allExtensionNumbersResponse !== undefined) {
      ExtensionNumberResponse.encode(
        message.allExtensionNumbersResponse,
        writer.uint32(42).fork()
      ).join()
    }
    if (message.listServicesResponse !== undefined) {
      ListServiceResponse.encode(message.listServicesResponse, writer.uint32(50).fork()).join()
    }
    if (message.errorResponse !== undefined) {
      ErrorResponse.encode(message.errorResponse, writer.uint32(58).fork()).join()
    }
    return writer
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ServerReflectionResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input)
    let end = length === undefined ? reader.len : reader.pos + length
    const message = createBaseServerReflectionResponse()
    while (reader.pos < end) {
      const tag = reader.uint32()
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break
          }

          message.validHost = reader.string()
          continue
        }
        case 2: {
          if (tag !== 18) {
            break
          }

          message.originalRequest = ServerReflectionRequest.decode(reader, reader.uint32())
          continue
        }
        case 4: {
          if (tag !== 34) {
            break
          }

          message.fileDescriptorResponse = FileDescriptorResponse.decode(reader, reader.uint32())
          continue
        }
        case 5: {
          if (tag !== 42) {
            break
          }

          message.allExtensionNumbersResponse = ExtensionNumberResponse.decode(
            reader,
            reader.uint32()
          )
          continue
        }
        case 6: {
          if (tag !== 50) {
            break
          }

          message.listServicesResponse = ListServiceResponse.decode(reader, reader.uint32())
          continue
        }
        case 7: {
          if (tag !== 58) {
            break
          }

          message.errorResponse = ErrorResponse.decode(reader, reader.uint32())
          continue
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break
      }
      reader.skip(tag & 7)
    }
    return message
  },
}

function createBaseFileDescriptorResponse(): FileDescriptorResponse {
  return { fileDescriptorProto: [] }
}

export const FileDescriptorResponse: MessageFns<FileDescriptorResponse> = {
  encode(message: FileDescriptorResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.fileDescriptorProto) {
      writer.uint32(10).bytes(v!)
    }
    return writer
  },

  decode(input: BinaryReader | Uint8Array, length?: number): FileDescriptorResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input)
    let end = length === undefined ? reader.len : reader.pos + length
    const message = createBaseFileDescriptorResponse()
    while (reader.pos < end) {
      const tag = reader.uint32()
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break
          }

          message.fileDescriptorProto.push(reader.bytes())
          continue
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break
      }
      reader.skip(tag & 7)
    }
    return message
  },
}

function createBaseExtensionNumberResponse(): ExtensionNumberResponse {
  return { baseTypeName: '', extensionNumber: [] }
}

export const ExtensionNumberResponse: MessageFns<ExtensionNumberResponse> = {
  encode(
    message: ExtensionNumberResponse,
    writer: BinaryWriter = new BinaryWriter()
  ): BinaryWriter {
    if (message.baseTypeName !== '') {
      writer.uint32(10).string(message.baseTypeName)
    }
    writer.uint32(18).fork()
    for (const v of message.extensionNumber) {
      writer.int32(v)
    }
    writer.join()
    return writer
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ExtensionNumberResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input)
    let end = length === undefined ? reader.len : reader.pos + length
    const message = createBaseExtensionNumberResponse()
    while (reader.pos < end) {
      const tag = reader.uint32()
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break
          }

          message.baseTypeName = reader.string()
          continue
        }
        case 2: {
          if (tag === 16) {
            message.extensionNumber.push(reader.int32())

            continue
          }

          if (tag === 18) {
            const end2 = reader.uint32() + reader.pos
            while (reader.pos < end2) {
              message.extensionNumber.push(reader.int32())
            }

            continue
          }

          break
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break
      }
      reader.skip(tag & 7)
    }
    return message
  },
}

function createBaseListServiceResponse(): ListServiceResponse {
  return { service: [] }
}

export const ListServiceResponse: MessageFns<ListServiceResponse> = {
  encode(message: ListServiceResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.service) {
      ServiceResponse.encode(v!, writer.uint32(10).fork()).join()
    }
    return writer
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListServiceResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input)
    let end = length === undefined ? reader.len : reader.pos + length
    const message = createBaseListServiceResponse()
    while (reader.pos < end) {
      const tag = reader.uint32()
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break
          }

          message.service.push(ServiceResponse.decode(reader, reader.uint32()))
          continue
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break
      }
      reader.skip(tag & 7)
    }
    return message
  },
}

function createBaseServiceResponse(): ServiceResponse {
  return { name: '' }
}

export const ServiceResponse: MessageFns<ServiceResponse> = {
  encode(message: ServiceResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== '') {
      writer.uint32(10).string(message.name)
    }
    return writer
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ServiceResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input)
    let end = length === undefined ? reader.len : reader.pos + length
    const message = createBaseServiceResponse()
    while (reader.pos < end) {
      const tag = reader.uint32()
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break
          }

          message.name = reader.string()
          continue
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break
      }
      reader.skip(tag & 7)
    }
    return message
  },
}

function createBaseErrorResponse(): ErrorResponse {
  return { errorCode: 0, errorMessage: '' }
}

export const ErrorResponse: MessageFns<ErrorResponse> = {
  encode(message: ErrorResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.errorCode !== 0) {
      writer.uint32(8).int32(message.errorCode)
    }
    if (message.errorMessage !== '') {
      writer.uint32(18).string(message.errorMessage)
    }
    return writer
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ErrorResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input)
    let end = length === undefined ? reader.len : reader.pos + length
    const message = createBaseErrorResponse()
    while (reader.pos < end) {
      const tag = reader.uint32()
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break
          }

          message.errorCode = reader.int32()
          continue
        }
        case 2: {
          if (tag !== 18) {
            break
          }

          message.errorMessage = reader.string()
          continue
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break
      }
      reader.skip(tag & 7)
    }
    return message
  },
}

export interface ServerReflectionClient {
  /**
   * The reflection service is structured as a bidirectional stream, ensuring
   * all related requests go to a single server.
   */

  serverReflectionInfo(
    request: Observable<ServerReflectionRequest>,
    metadata?: Metadata
  ): Observable<ServerReflectionResponse>
}

export interface ServerReflectionController {
  /**
   * The reflection service is structured as a bidirectional stream, ensuring
   * all related requests go to a single server.
   */

  serverReflectionInfo(
    request: Observable<ServerReflectionRequest>,
    metadata?: Metadata
  ): Observable<ServerReflectionResponse>
}

export function ServerReflectionControllerMethods() {
  return function (constructor: Function) {
    const grpcMethods: string[] = []
    for (const method of grpcMethods) {
      const descriptor: any = Reflect.getOwnPropertyDescriptor(constructor.prototype, method)
      GrpcMethod('ServerReflection', method)(constructor.prototype[method], method, descriptor)
    }
    const grpcStreamMethods: string[] = ['serverReflectionInfo']
    for (const method of grpcStreamMethods) {
      const descriptor: any = Reflect.getOwnPropertyDescriptor(constructor.prototype, method)
      GrpcStreamMethod('ServerReflection', method)(
        constructor.prototype[method],
        method,
        descriptor
      )
    }
  }
}

export const SERVER_REFLECTION_SERVICE_NAME = 'ServerReflection'

export type ServerReflectionService = typeof ServerReflectionService
export const ServerReflectionService = {
  /**
   * The reflection service is structured as a bidirectional stream, ensuring
   * all related requests go to a single server.
   */
  serverReflectionInfo: {
    path: '/grpc.reflection.v1.ServerReflection/ServerReflectionInfo',
    requestStream: true,
    responseStream: true,
    requestSerialize: (value: ServerReflectionRequest) =>
      Buffer.from(ServerReflectionRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer) => ServerReflectionRequest.decode(value),
    responseSerialize: (value: ServerReflectionResponse) =>
      Buffer.from(ServerReflectionResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer) => ServerReflectionResponse.decode(value),
  },
} as const

export interface ServerReflectionServer extends UntypedServiceImplementation {
  /**
   * The reflection service is structured as a bidirectional stream, ensuring
   * all related requests go to a single server.
   */
  serverReflectionInfo: handleBidiStreamingCall<ServerReflectionRequest, ServerReflectionResponse>
}

export interface MessageFns<T> {
  encode(message: T, writer?: BinaryWriter): BinaryWriter
  decode(input: BinaryReader | Uint8Array, length?: number): T
}
