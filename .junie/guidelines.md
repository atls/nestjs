# Project Guidelines

## Scope

- репа — **NestJS-монорепа** с набором переиспользуемых бэкенд-модулей, а не приложение
- цель изменений — расширение/улучшение модулей без ломания существующих контрактов
- публичные API уже опубликованных пакетов **ломать нельзя**

## Структура репы

- Yarn workspaces: `packages/**/*`, `examples/**/*`
- каждый пакет живёт в `packages/<package-name>`
- package manager строго **yarn@4**
- TypeScript + ESM, `type: module`

## Архитектура

- классическая NestJS-модульность
- логика в сервисах/провайдерах, не в контроллерах
- DI везде, без хардкода
- конфигурация через providers / options pattern
- без FSD, без фронтовых паттернов

## Новые модули

- каждый новый модуль обязан:
  - иметь README с описанием интеграции
  - иметь **пример использования** в `examples/<module-name>`
  - быть подключаемым как обычный NestJS-модуль
- структура нового пакета должна повторять существующие пакеты в `packages/`

## Примеры (examples)

- примеры должны быть минимальными, но рабочими
- показывать реальный сценарий интеграции
- использовать тот же Yarn workspace, без локальных костылей
- если есть proto / схемы — они лежат внутри примера

## Тесты

- используется Jest
- если у пакета есть тесты — они обязаны проходить
- для интеграций допустимы integration-тесты
- перед финальным результатом:
  - `yarn workspaces run build`
  - тесты не должны падать

## Code style

- строгая типизация, без `any`
- дроблёные импорты
- ошибки через Nest-исключения (`HttpException`, `RpcException`)
- логирование через существующие logger-модули, не `console.log`
- аккуратная работа с peerDependencies

## CI / tooling

- не ломать существующие workflow
- не менять package manager, лицензии, базовые версии без причины
- build и prepack/postpack пайплайны должны сохраняться

## Что запрещено

- ломать публичные API существующих пакетов
- тащить лишние зависимости
- менять архитектуру NestJS
- добавлять FSD, MVC-фантазии и прочий мусор
- выполнять опасные shell-команды без необходимости (Brave mode — осторожно)

## Поведение Junie

- сначала анализ существующего кода
- потом минимальное изменение
- без шумных рефакторов
- если изменение архитектурное — объяснять зачем
